// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: mobile_otp.sql

package db

import (
	"context"
)

const checkOtp = `-- name: CheckOtp :one
SELECT COUNT(*) > 0 AS is_valid
FROM mobile_otp
WHERE user_id = $1
  AND otp = $2
  AND valid_till > NOW()
`

type CheckOtpParams struct {
	UserID int32  `json:"user_id"`
	Otp    string `json:"otp"`
}

func (q *Queries) CheckOtp(ctx context.Context, arg CheckOtpParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkOtp, arg.UserID, arg.Otp)
	var is_valid bool
	err := row.Scan(&is_valid)
	return is_valid, err
}

const createNewOtp = `-- name: CreateNewOtp :exec
INSERT INTO mobile_otp (user_id, otp, valid_till)
VALUES ($1, $2, NOW() + INTERVAL '5 minutes')
`

type CreateNewOtpParams struct {
	UserID int32  `json:"user_id"`
	Otp    string `json:"otp"`
}

func (q *Queries) CreateNewOtp(ctx context.Context, arg CreateNewOtpParams) error {
	_, err := q.db.Exec(ctx, createNewOtp, arg.UserID, arg.Otp)
	return err
}

const getValidOtpForUserName = `-- name: GetValidOtpForUserName :one
SELECT mo.otp,u.username
FROM mobile_otp mo
JOIN users u ON mo.user_id = u.id
WHERE u.username = $1           
  AND mo.valid_till > NOW()      
  AND mo.is_used = FALSE         
LIMIT 1
`

type GetValidOtpForUserNameRow struct {
	Otp      string `json:"otp"`
	Username string `json:"username"`
}

func (q *Queries) GetValidOtpForUserName(ctx context.Context, username string) (GetValidOtpForUserNameRow, error) {
	row := q.db.QueryRow(ctx, getValidOtpForUserName, username)
	var i GetValidOtpForUserNameRow
	err := row.Scan(&i.Otp, &i.Username)
	return i, err
}

const markOtpUsed = `-- name: MarkOtpUsed :exec
UPDATE mobile_otp
SET is_used = TRUE
WHERE otp = $1                   
  AND user_id = (
      SELECT id FROM users WHERE username = $2
  )
`

type MarkOtpUsedParams struct {
	Otp      string `json:"otp"`
	Username string `json:"username"`
}

func (q *Queries) MarkOtpUsed(ctx context.Context, arg MarkOtpUsedParams) error {
	_, err := q.db.Exec(ctx, markOtpUsed, arg.Otp, arg.Username)
	return err
}
